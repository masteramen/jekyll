---
layout: post
title:  "《深入理解java虚拟机》学习笔记之编译优化技术"
title2:  "《深入理解java虚拟机》学习笔记之编译优化技术"
date:   2017-01-01 23:50:20  +0800
source:  "http://www.jfox.info/%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3java%e8%99%9a%e6%8b%9f%e6%9c%ba-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%e4%b9%8b%e7%bc%96%e8%af%91%e4%bc%98%e5%8c%96%e6%8a%80%e6%9c%af.html"
fileName:  "20170100920"
lang:  "zh_CN"
published: true
permalink: "%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3java%e8%99%9a%e6%8b%9f%e6%9c%ba-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%e4%b9%8b%e7%bc%96%e8%af%91%e4%bc%98%e5%8c%96%e6%8a%80%e6%9c%af.html"
---
{% raw %}
**郑重声明：本片博客是学习<深入理解Java虚拟机>一书所记录的笔记，内容基本为书中知识．**
Java程序员有一个共识，以编译方式执行本地代码比解释方式更快，之所以有这样的共识，除去虚拟机解释执行字节码时额外消耗时间的原因外，还有一个很重要的原因就是虚拟机设计团队几乎把对代码的所有优化措施都集中在了即时编译器之中（在JDK 1.3之 
后，Javac就去除了-O选项，不会生成任何字节码级别的优化代码了），因此一般来说，即时编译器产生的本地代码会比Javac产生的字节码更加优秀[1]。本篇博客，我们将一起学习HotSpot虚拟机的即时编译器在生成代码时采用的代码优化技术。

## **优化技术概览**

在Sun官方的Wiki上，HotSpot虚拟机设计团队列出了一个相对比较全面的、 在即时编译器中采用的优化技术列表，其中有不少经典编译器的优化手段，也有许多针对Java语言（准确地说是针对运行在Java虚拟机上的所有语言）本身进行的优化技术。 
![](2e34720.png)

下面举一个简单的例子，即通过Java代码变化来展示其中几种优化技术是如何发挥作用的。

优化前的原始代码

    static class B{
    intvalue；
    final intget（）{
    returnvalue；
    } } p
    ublic void foo（）{
    y=b.get（）；
    //……do stuff……
    z=b.get（）；
    sum=y+z；
    }

首先需要明确的是，这些代码优化变换是建立在代码的某种中间表示或机器码之上，**绝不是建立在Java源码之上的**，为了展示方便，这里使用了Java语言的语法来表示这些优化技术所发挥的作用。

上述代码已经非常简单了，但是仍有许多优化的余地。 第一步进行方法内联（Method Inlining），方法内联的重要性要高于其他优化措施，它的主要目的有两个，一是去除方法调用的成本（如建立栈帧等），二是为其他优化建立良好的基础，方法内联膨胀之后可以便于在更大范围上采取后续的优化手段，从而获取更好的优化效果。 因此，各种编译器一般都会把内联优化放在优化序列的最靠前位置。 内联后的代码下所示

内联后的代码

    publicvoid foo（）{
    y=b.value；
    //……do stuff……
    z=b.value；
    sum=y+z；
    }

第二步进行冗余访问消除（Redundant Loads Elimination），假代码中间注释掉的“dostuff……”所代表的操作不会改变b.value的值，那就可以把“z=b.value”替换为“z=y”，因为上一句“y=b.value”已经保证了变量y与b.value是一致的，这样就可以不再去访问对象b的局部变量了。 如果把b.value看做是一个表达式，那也可以把这项优化看成是公共子表达式消除 
（Common Subexpression Elimination），优化后的代码如下所示。

    publicvoid foo（）{
    y=b.value；
    //……do stuff……
    z=y；
    sum=y+z；
    }

第三步我们进行复写传播（Copy Propagation），因为在这段程序的逻辑中并没有必要使用一个额外的变量“z”，它与变量“y”是完全相等的，因此可以使用“y”来代替“z”。 复写传播之后程序如下所示。

复写传播的代码

    publicvoid foo（）{
    y=b.value；
    //……do stuff……
    y=y；
    sum=y+y；
    }

第四步我们进行无用代码消除（Dead Code Elimination）。 无用代码可能是永远不会被执行的代码，也可能是完全没有意义的代码，因此，它又形象地称为“Dead Code”，在上面代码 
清单中，“y=y”是没有意义的，把它消除后的程序如下所示

进行无用代码消除的代码

    publicvoid foo（）{
    y=b.value；
    //……do stuff……
    sum=y+y；
    }

经过四次优化之后，省略了许多语句（体现在字节码和机器码指令上的差距会更大），执行效率也会更高。

接下来，我们将继续查看如下的几项最有代表性的优化技术是如何运作的，它们分别是：

语言无关的经典优化技术之一：公共子表达式消除。 
语言相关的经典优化技术之一：数组范围检查消除。 
最重要的优化技术之一：方法内联。 
最前沿的优化技术之一：逃逸分析。

## **公共子表达式消除**

公共子表达式消除是一个普遍应用于各种编译器的经典优化技术，它的含义是：如果一个表达式E已经计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就成为了公共子表达式。 对于这种表达式，没有必要花时间再对它进行计算，只需要直接用前面计算过的表达式结果代替E就可以了。 如果这种优化仅限于程序的基本块内，便称为局部公共子表达式消除，如果这种优化的范围涵盖了多个基本块，那就称为全局公共子表达式消除。

简单的例子来说明它的优化过程：

    int d=（c * b）*12+a+（a+b * c）；

如果这段代码交给Javac编译器则不会进行任何优化，那生成的代码将如下所示，是完全遵照Java源码的写法直译而成的。

未做任何优化的字节码

    iload_2//b
    imul//计算b * c
    bipush 12//推入12
    imul//计算（c * b）*12
    iload_1//a
    iadd//计算（c * b）*12+a
    iload_1//a
    iload_2//b
    iload_3//c
    imul//计算b * c
    iadd//计算a+b * c
    iadd//计算（c * b）*12+a+（a+b * c）
    istore 4

当这段代码进入到虚拟机即时编译器后，它将进行如下优化：编译器检测到“c * b”与“b* c”是一样的表达式，而且在计算期间b与c的值是不变的。 因此，这条表达式就可能被视为：

    int d=E*12+a+（a+E）；

这时，编译器还可能（取决于哪种虚拟机的编译器以及具体的上下文而定）进行另外一种优化：代数化简，把表达式变为：

    int d=E*13+a*2；

表达式进行变换之后，再计算起来就可以节省一些时间了。 

## **数组边界检查消除**

数组边界检查消除（Array Bounds Checking Elimination）是即时编译器中的一项语言相关的经典优化技术。 我们知道Java语言是一门动态安全的语言，对数组的读写访问也不像C、 C++那样在本质上是裸指针操作。 如果有一个数组foo[]，在Java语言中访问数组元素foo[i]的时候系统将会自动进行上下界的范围检查，即检查i必须满足i＞=0＆＆i＜foo.length这个条件，否则将抛出一个运行时异常：java.lang.ArrayIndexOutOfBoundsException。 但是对于虚拟机的执行子系统来说，每次数组元素的读写都带有一次隐含的条件判定操作，对于拥有大量数组访问的程序代码，这无疑也是一种性能负担。

数组边界检查是不是必须在运行期间一次不漏地检查则是可以“商量”的事情。 例如下面这个简单的情况：数组下标是一个常量，如foo[3]，只要在编译期根据数据流分析来确定foo.length的值，并判断下标“3”没有越界，执行的时候就无须判断了。 更加常见的情况是数组访问发生在循环之中，并且使用循环变量来进行数组访问，如果编译器只要通过数据流分析就可以判定循环变量的取值范围永远在区间[0，foo.length）之内，那在整个循环中就可以把数组的上下界检查消除，这可以节省很多次的条件判断操作。

将这个数组边界检查的例子放在更高的角度来看，大量的安全检查令编写Java程序比编写C/C++程序容易很多， 但这些安全检查也导致了相同的程序，Java要比C/C++做更多的事情（各种检查判断），这些事情就成为一种隐式开销，如果处理不好它们，就很可能成为一个Java语言比C/C++更慢的因素。 要消除这些隐式开销， 
**除了如数组边界检查优化这种尽可能把运行期**
{% endraw %}