---
layout: post
title:  "漫画算法：什么是跳跃表？"
title2:  "漫画算法：什么是跳跃表？"
date:   2017-01-01 23:52:57  +0800
source:  "https://www.jfox.info/%e6%bc%ab%e7%94%bb%e7%ae%97%e6%b3%95%e4%bb%80%e4%b9%88%e6%98%af%e8%b7%b3%e8%b7%83%e8%a1%a8.html"
fileName:  "20170101077"
lang:  "zh_CN"
published: true
permalink: "2017/%e6%bc%ab%e7%94%bb%e7%ae%97%e6%b3%95%e4%bb%80%e4%b9%88%e6%98%af%e8%b7%b3%e8%b7%83%e8%a1%a8.html"
---
{% raw %}
拍卖行的商品总数量有几十万件，对应数据库商品表的几十万条记录。

如果是按照商品名称精确查询还好办，可以直接从数据库查出来，最多也就上百条记录。

如果是没有商品名称的全量查询怎么办？总不可能把数据库里的所有记录全查出来吧，而且还要支持不同字段的排序。

所以，只能提前在内存中存储有序的全量商品集合，每一种排序方式都保存成独立的集合，每次请求的时候按照请求的排序种类，返回对应的集合。

比如按价格字段排序的集合：

比如按等级字段排序的集合：

需要注意的是，当时还没有Redis这样的内存数据库，所以小灰只能自己实现一套合适的数据结构来存储。

![](01c4603.jpeg)

拍卖行商品列表是线性的，最容易表达线性结构的自然是数组和链表。可是，无论是数组还是链表，在插入新商品的时候，都会存在性能问题。

按照商品等级排序的集合为例，如果使用数组，插入新商品的方式如下：

![](06df0e3.jpeg)

如果要插入一个等级是3的商品，首先要知道这个商品应该插入的位置。使用二分查找可以最快定位，这一步时间复杂度是O（logN）。

插入过程中，原数组中所有大于3的商品都要右移，这一步时间复杂度是O（N）。所以总体时间复杂度是O（N）。

如果使用链表，插入新商品的方式如下：

![](c9150a4.jpeg)

如果要插入一个等级是3的商品，首先要知道这个商品应该插入的位置。链表无法使用二分查找，只能和原链表中的节点逐一比较大小来确定位置。这一步的时间复杂度是O（N）。

插入的过程倒是很容易，直接改变节点指针的目标，时间复杂度O（1）。因此总体的时间复杂度也是O（N）。

这对于拥有几十万商品的集合来说，这两种方法显然都太慢了。
{% endraw %}