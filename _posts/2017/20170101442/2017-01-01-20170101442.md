---
layout: post
title:  "深入了解Java虚拟机（2）垃圾收集器与内存分配策略"
title2:  "深入了解Java虚拟机（2）垃圾收集器与内存分配策略"
date:   2017-01-01 23:59:02  +0800
source:  "http://www.jfox.info/%e6%b7%b1%e5%85%a5%e4%ba%86%e8%a7%a3java%e8%99%9a%e6%8b%9f%e6%9c%ba2%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8%e4%b8%8e%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e7%ad%96%e7%95%a5.html"
fileName:  "20170101442"
lang:  "zh_CN"
published: true
permalink: "%e6%b7%b1%e5%85%a5%e4%ba%86%e8%a7%a3java%e8%99%9a%e6%8b%9f%e6%9c%ba2%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8%e4%b8%8e%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e7%ad%96%e7%95%a5.html"
---
{% raw %}
# 深入了解Java虚拟机（2）垃圾收集器与内存分配策略 


# 垃圾收集器与内存分配策略

 　　由于JVM中对象的频繁操作是在堆中，所以主要回收的是堆内存，方法区中的回收也有，但是比较谨慎

### 一、对象死亡判断方法

#### 　　1.引用计数法

　　　　就是如果对象被引用一次，就给计数器+1，否则-1

　　　　实现简单，但是无法解决对象相互引用的问题；实际上JVM也不是使用的此种方式，因此已下的程序我们会看到内存被回收了

    /**
     *testGC（）方法执行后，objA和objB会不会被GC呢？
     *@author zzm
     */class ReferenceCountingGC{
        public Object instance=null；
        privatestaticfinalint _1MB = 1024*1024;
        /**
         *这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过
         */privatebyte[]bigSize=newbyte[2*_1MB];
        publicstaticvoid testGC(){
            ReferenceCountingGC objA=new ReferenceCountingGC();
            ReferenceCountingGC objB=new ReferenceCountingGC();
            objA.instance=objB;
            objB.instance=objA;
            objA=null;
            objB=null;
            //假设在这行发生GC,objA和objB是否能被回收？        System.gc();
        }
    }

#### 　　2.可达性分析

　　　　定义一些GCroot，如果从GCroot到对象是不可达的，那么对象就可以被回收

　　　　可能的gcroot:栈中的存放的对象的引用、方法区中静态属性和常量引用的对象、本地方法栈引用的对象（native）

　　　　主流的jvm都是使用的此种方式

![](0a10787.png)

#### 　　3.引用

　　　　无论通过什么方式，都是通过“引用”来判断！

　　　　在JVM中引用分为四种：强、软、弱、虚（具体参考这篇文章：[http://www.cnblogs.com/zhangxinly/p/6978355.html](http://www.jfox.info/go.php?url=http://www.cnblogs.com/zhangxinly/p/6978355.html)）

#### 　　4.finalize方法

　　　　如果对象不可达，对象将被标记，

　　　　类覆写了此方法，且对象的此方法从未被JVM执行过，则对象被放入一个队列，等待一个线程来执行此对象的方法（注意只会执行一次）

　　　　可以使用这种特性在对象不可达，被发现为可回收的状态下，重新回收对象；就是在finalize方法中重新建立强引用

　　　　不建议使用，了解即可　

    /**
     * 此代码演示了两点：
     * 1.对象可以在被GC时自我拯救。
     * 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次
     *
     * @author zzm
     */class FinalizeEscapeGC {
        publicstatic FinalizeEscapeGC SAVE_HOOK = null;
    
        publicvoid isAlive() {
            System.out.println("yes,i am still alive：)");
        }
    
        protectedvoid finalize() throws Throwable {
            super.finalize();
            System.out.println("finalize mehtod executed！");
            FinalizeEscapeGC.SAVE_HOOK = this;
        }
    
        publicstaticvoid main(String[] args) throws Throwable {
            SAVE_HOOK = new FinalizeEscapeGC();
            //对象第一次成功拯救自己
            SAVE_HOOK = null;
            System.gc();
            //因为finalize方法优先级很低，所以暂停0.5秒以等待它
            Thread.sleep(500);
            if (SAVE_HOOK != null) {
                SAVE_HOOK.isAlive();
            } else {
                System.out.println("no,i am dead：(");
            }
            //下面这段代码与上面的完全相同，但是这次自救却失败了
            SAVE_HOOK = null;
            System.gc();
            //因为finalize方法优先级很低，所以暂停0.5秒以等待它
            Thread.sleep(500);
            if (SAVE_HOOK != null) {
                SAVE_HOOK.isAlive();
            } else {
                System.out.println("no,i am dead：(");
            }
        }
    }

#### 　　5.方法区回收

　　　　方法区中的常量回收：在程序中没有任何地方使用到如：str=“abc”,则回收

　　　　类回收：类所有实例全被回收、类加载器被回收、类的Class对象未被引用无法在任何地方通过反射调用，则该类可以被回收卸载

　　　　在如今框架动态代理大行其道的今天，JVM必须有卸载类的方法，不然出现泄漏

### 二、回收算法

#### 　　1.标记-清除算法

　　　　标记不可达对象，然后jvm进行统一回收

　　　　缺点：

　　　　　　效率不高，两个过程效率都不高

　　　　　　回收后内存不连续，因为是从中移除掉不可达的，会导致大量碎片，如果JVM要分配一个连续的大内存，将会产生问题

#### 　　2.复制算法

　　　　1）将内存分为两份A和B，如果A不够用了，就将A中存活的对象复制到B中（复制过去的肯定小于等于
{% endraw %}